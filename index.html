<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="description" content="brief description" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SINGLY LINKED LIST</title>
  <link rel="icon" href="images/vlab-logo.png" type="image/x-icon" />
  <link rel="stylesheet" href="styles.css" />
  <link rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/base16/harmonic16-dark.min.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.8/clipboard.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
</head>

<body>
  <header class="header">
    <div class="logo-container">
      <div class="logo">
        <a href="https://www.vlab.andcollege.du.ac.in" rel="noopener" target="_blank">
          <img class="logo-img" src="images/logo.png" alt="VLab" />
        </a>
      </div>
      <h1 class="vlab">V-Lab@ANDC</h1>
    </div>

    <div class="menu-toggle" onclick="toggleMenu()">☰</div>
    <nav class="nav-menu" id="small-screen">
      <div class="close-btn" onclick="toggleMenu()">✖</div>
      <a href="https://www.vlab.andcollege.du.ac.in">Home</a>
      <a href="https://www.vlab.andcollege.du.ac.in#labs_section">Labs</a>
      <a href="https://www.vlab.andcollege.du.ac.in#team">Team</a>
      <a href="https://www.andcollege.du.ac.in">College Website</a>
    </nav>
  </header>

  <div class="yourvlabtitle">
    <h1><b>SINGLY LINKED LIST</b></h1>
  </div>

  <div class="pageview">
    <nav class="navigation">
      <button class="link" onclick="switchContent('aim')">
        <img class="icon" src="images/Aim_img.png" alt="Aim" />
        <span>Aim</span>
      </button>

      <button class="link" onclick="switchContent('theory')">
        <img class="icon" src="images/theory_img.png" alt="THEORY" />
        <span>Theory & Appli.</span>
      </button>

      <button class="link" onclick="switchContent('procedure')">
        <img class="icon" src="images/procedure_img.png" alt="PROCEDURE" />
        <span>Procedure</span>
      </button>

      <button class="link" onclick="switchContent('practice')">
        <img class="icon" src="images/practice_img.png" alt="PRACTICE" />
        <span>Practice</span>
      </button>

      <button class="link" onclick="switchContent('code')">
        <img class="icon" src="images/code_img.png" alt="CODES" />
        <span>Codes</span>
      </button>

      <button class="link" onclick="switchContent('result')">
        <img class="icon" src="images/result_img.png" alt="RESULT" />
        <span>Result</span>
      </button>

      <button class="link" onclick="switchContent('quiz')">
        <img class="icon" src="images/quiz_img.png" alt="QUIZ" />
        <span>Quiz</span>
      </button>

      <button class="link" onclick="switchContent('references')">
        <img class="icon" src="images/reference_img.png" alt="REFERENCE" />
        <span>References</span>
      </button>
      <button class="link" onclick="switchContent('tnt')">
        <img class="icon" src="images/tnt_img.png" alt="TEAM & TOOLS" />
        <span>Team & Tools</span>
      </button>
    </nav>

    <section class="main_practical">
      <!-- Aim -->
      <div class="container" id="aim">
        <div class="title">Aim</div>
        <div class="content">
          <p> To demonstrate the working of a Singly Linked List (SLL), which includes its creation, traversal ,
            insertion of elements, deletion of elements, and search for elements through visualization.</p>
        </div>
      </div>

      <!-- Theory & Applications -->
      <div class="container" id="theory">
        <div class="title">Theory & Applications</div>
        <div class="content">
          <p>
            A <b>Singly Linked List</b> (SLL) is a linear data structure consisting of nodes in which each node is
            accessible through pointer stored in its immediate predecessor. Single linked list is traversed from first
            node to the last node using pointers in the forward direction only. It is not feasible to randomly access
            any element in the list. The first node is pointed by head node which contains the address of first node.
            Initially, head is Null (∅) indicating empty linked list.
          </p>
          <br />

          <h3>In a Singly Linked List, each node contains two components:</h3>
          <span>
            <ul>
              <li>
                <big><b>Data :</b></big>
              </li>
              <big>This stores the actual value or information (e.g., an integer, string, object, etc.).</big>
              <span><big><b>Example :</b></big>Example: 5, "Hello", {name: "Alice", age: 30}, etc.</span>
            </ul>
            <ul>
              <li>
                <big><b>Pointer (or next address):</b></big>
              </li>
              <span><big>This holds the reference or address of the next node in the list. If it's the last node, the
                  pointer is usually set to null (or None in Python).</big></span>
            </ul>
          </span>
          <br />
          <div class="content_all">
            <h1>Applications of Singly Linked List: </h1>
            <br />
            <ol start="1">
              <li><b> Dynamic Memory Allocation : </b></li>
            </ol>
            <ul>
              <li><b> Use-case : </b></li>
              <p>Operating Systems and memory managers.</p>
              <br />
              <li><b>Explanation : </b></li>
              <p>Singly linked lists are used to keep track of free and allocated memory blocks in heap management. Each
                memory block contains a pointer to the next block</p>
              <br />
              <li><b>Application : </b></li>
              <p>Efficient insertion and deletion of memory blocks.</p>
            </ul>
            <ol start="2">
              <li><b>Undo Functionality in Applications</b></li>
            </ol>
            <ul>
              <li><b> Use-case : </b></li>
              <p> Text editors like Microsoft Word, Google Docs.</p>
              <br />
              <li><b>Explanation : </b></li>
              <p>Each action (e.g., typing a letter) is stored as a node. Pressing "undo"
                traverses back through the actions using the links.</p>
              <br />
              <li><b>Application : </b></li>
              <p> Enables efficient rollback of previous operations.</p>
            </ul>
            <ol start="3">
              <li><b>Web Browser Forward Navigation</b></li>
            </ol>
            <ul>
              <li><b> Use-case : </b></li>
              <p> Web browsers.</p>
              <br />
              <li><b>Explanation : </b></li>
              <p>While back navigation uses a stack, forward navigation (redoing pages) can
                be managed using a singly linked list.</p>
              <br />
              <li><b>Application : </b></li>
              <p> Allows efficient forward traversal through visited pages.</p>
            </ul>
            <ol start="4">
              <li><b> Polynomial Arithmetic</b></li>
            </ol>
            <ul>
              <li><b> Use-case : </b></li>
              <p> Scientific and Engineering computations.</p>
              <br />
              <li><b>Explanation : </b></li>
              <p> Polynomials can be represented as a linked list where each node holds a
                coefficient and exponent.</p>
              <br />
              <li><b>Application : </b></li>
              <p> Enables efficient polynomial addition, subtraction, and multiplication without
                memory waste.</p>
            </ul>
            <ol start="5">
              <li><b>Real-time Task Scheduling</b></li>
            </ol>
            <ul>
              <li><b> Use-case : </b></li>
              <p> Embedded systems and OS kernels.</p>
              <br />
              <li><b>Explanation : </b></li>
              <p> A task queue can be implemented as a singly linked list where each task is a
                node.</p>
              <br />
              <li><b>Application : </b></li>
              <p> Easy insertion of new tasks and deletion of completed ones in linear time.
              </p>
            </ul>
          </div>
        </div>

      </div>

      <!-- Procedure -->
      <div class="container" id="procedure">
        <div class="title"><b>Linked List Procedure</b></div>
        <div class="content">
          <br />
          <br />
          <big><b> This section presents illustrations of key operations on a singly linked list, including insertions
              at
              indices 0, 3, and 4, as well as deletions from the same positions. These operations will be demonstrated
              on
              an initial linked list comprising four nodes: Node A, Node B, Node C, and Node D.</b></big>
          <br />
          <br />
          <span>
            <ul>
              <li>
                <big><b>Data :</b></big>
              </li>
              <big>This stores the actual value or information (e.g., an integer, string, object, etc.).</big>
              <span><big><b>Example :</b></big>Example: 5, "Hello", {name: "Alice", age: 30}, etc.</span>
            </ul>
            <ul>
              <li>
                <big><b>Pointer (or next address):</b></big>
              </li>
              <span><big>This holds the reference or address of the next node in the list. If it's the last node, the
                  pointer is usually set to null (or None in Python).</big></span>
            </ul>
            <ul>
              <li>
                <big><b>Time Complexity :</b></big>
              </li>
              <big><b>This section presents illustrations of key operations on a singly linked list, including
                  insertions at indices 0, 3, and 4, as well as deletions from the same positions.</b>These operations
                will be demonstrated on an initial linked list comprising four nodes:<b>Node A, Node B, Node C, and Node
                  D.</b></big>
            </ul>
          </span>
          <img id="s1_img" src="s1.png" alt="Example 1 of the singly">
          <br />
          <br />
          <big><b>Insertion : </b></big>
          <br />
          <ul>
            <li><b>Insertion :</b></li>
            <p>Insertion in a singly linked list involves creating a new node and adjusting pointers to place it at the
              desired position without disrupting the structure of the list.</p>
          </ul>

          <h3>Insertion at Index 0 :</h3>
          <ul>
            <li><b> Procedure: </b></li>
            <ol>
              <li>Create a new node (Node D).</li>
              <li>Set the new node's (Node D) next pointer to the current head (Node A).</li>
              <li>Update the head to point to the new node (Node D).</li>
            </ol>
            <br />
            <li><b>Time Complexity: O(1)</b></li>
            <p> Since Index 1 is a fixed position, this operation takes a constant amount of time, regardless of the
              list's total length.</p>
            <br />
          </ul>
          <br />
          <img id="s2_img" src="s2_new.png" alt="insertion_begining">
          <br />
          <h3>Result -></h3>
          <br/>
          <img id="s3_img" src="s3.png" alt="start">
          <br />
          <br/>
          <h3>Insertion at Index 3 :</h3>
          <ul>
            <li><b> Procedure: </b></li>
            <ol>
              <li>Create a new node (Node D).</li>
              <li>Traverse the list to the node just before the desired position (Node B)..</li>
              <li>Set the new node's (Node D) next pointer to the next node in the sequence (Node C).</li>
              <li>Update the preceding node's (Node B) next pointer to point to the new node (Node D).</li>
            </ol>
            <br />
            <li><b>Time Complexity: O(n)</b></li>
            <p>This is because, in the worst case, you have to traverse a significant portion of the list to find the
              correct position.</p>
            <br />
          </ul>
          <br />
          <img id="s4_img" src="s4.png" alt="s4_img">
          <br />
          <h3>Result -></h3>
          <br />
          <img id="s5_img" src="s5.png" alt="s6_img">
          <br />
          <br />
          <h3>Insertion at Index 4 :</h3>
          <ul>
            <li><b> Procedure: </b></li>
            <ol>
              <li>Create a new node (Node D).</li>
              <li>Traverse the list to find the last node (Node C).</li>
              <li>Point the last node's (Node C) next pointer to the new node (Node D).</li>
            </ol>
            <br />
            <li><b>Time Complexity: O(n)</b></li>
            <p>You must traverse the entire list to find the last node before you can insert the new one.</p>
            <br />
          </ul>
          <img id="s6_img" src="s6.png" alt="s6_img">
          <br />
          <h3>Result -></h3>
          <br />
          <img id="s7_img" src="s7.png" alt="s7_img">
          <br />
          <br/>
          <h3>Deletion at Index 0 :</h3>
          <ul>
            <li><b> Procedure: </b></li>
            <ol>
              <li>Identify the first node (Node A) as the target for deletion.</li>
              <li>Update the list's head pointer to point to the second node in the list (Node B).</li>
            </ol>
            <br />
            <li><b>Time Complexity: O(n)</b></li>
            <p>This is a constant time operation because it only involves changing the head pointer, regardless of the
              list's size.</p>
            <br />
          </ul>
          <br/>
          <img id="s8_img" src="s8.png" alt="s8_img">
          <br />
          <h3>Result-></h3>
          <br />
          <img id="s9_img" src="s9.png" alt="s9_img">
          <br />
          <br />
          <h3>Deletion at Index 3 :</h3>
          <ul>
            <li><b> Procedure: </b></li>
            <ol>
              <li>Traverse to the node just before the one to be deleted (Node B).</li>
              <li>Update the next pointer of this preceding node (Node B) to "skip" the target node (Node C) and point
                directly to the node that follows it (Node D).</li>
            </ol>
            <br />
            <li><b>Time Complexity: O(n)</b></li>
            <p>Finding the node just before the target requires traversing the list from the beginning.</p>
            <br />
          </ul>
          <img id="s10_img" src="s10.png" alt="s10_img">
          <br/>
          <h3>Result -></h3>
          <img id="s11_img" src="s11.png" alt="s11_img">
          <br />
          <br />
          <h3>Deletion at Index 4 :</h3>
          <ul>
            <li><b> Procedure: </b></li>
            <ol>
              <li>Traverse the list to find the second-to-last node (Node C).</li>
              <li>Set the next pointer of this second-to-last node to NULL, effectively disconnecting the last node
                (Node D).</li>
            </ol>
            <br />
            <li><b>Time Complexity: O(n)</b></li>
            <p>Finding the node just before the target requires traversing the list from the beginning.</p>
            <br />
          </ul>
          <img id="s12_img" src="s12.png" alt="s12_img">
          <br/>
          <h3>Result-></h3>
          <br />
          <img id="s13_img" src="s13.png" alt="s13_img">
          <br />

        </div>
      </div>

      <!-- Code -->
      <div class="container" id="code">
        <div class="title">Code</div>
        <p>Example programs</p>
        <div class="switch-container">
          <input class="togswt" type="radio" id="cppRadio" name="codeSwitch" checked />
          <label for="cppRadio">C++</label>

          <input class="togswt" type="radio" id="pythonRadio" name="codeSwitch" />
          <label for="pythonRadio">Python</label>
        </div>

        <div class="code-blocks">
          <div id="cppCode" class="code-block active">
            <div class="code-content">
              <pre><code class="language-cpp">
        #C++ code        

        <!-- &lt and &gt for including the angular brackets in html code -->
              #include &lt;iostream&gt;
              using namespace std;

              // Node class
              class Node {
              private:
              int data;
              Node* next;

              public:
              Node(int value) { // Constructor to initialize a node
              data = value;
              next = nullptr;
              }

              friend class SinglyLinkedList;
              };

              // Singly Linked List class
              class SinglyLinkedList {
              private:
              Node* head; // Pointer to the first node

              public:
              // Constructor
              SinglyLinkedList() {
              head = nullptr;
              }

              // Insert at the start
              void insertAtStart(int value) {
              Node* newNode = new Node(value);
              newNode->next = head;
              head = newNode;
              }

              // Insert at the end
              void insertAtEnd(int value) {
              Node* newNode = new Node(value);
              if (!head) { // If the list is empty
              head = newNode;
              return;
              }
              Node* temp = head;
              while (temp->next) {
              temp = temp->next;
              }
              temp->next = newNode;
              }

              // Insert in the middle (after a given value)
              void insertAfter(int target, int value) {
              Node* temp = head;
              while (temp && temp->data != target) {
              temp = temp->next;
              }
              if (temp) { // If the target node is found
              Node* newNode = new Node(value);
              newNode->next = temp->next;
              temp->next = newNode;
              } else {
              cout << "Target value not found!\n" ; } } // Delete at the start void deleteAtStart() { if (!head) { // If
                the list is empty cout << "List is empty!\n" ; return; } Node* temp=head; head=head->next;
                delete temp;
                }

                // Delete at the end
                void deleteAtEnd() {
                if (!head) { // If the list is empty
                cout << "List is empty!\n" ; return; } if (!head->next) { // If there is only one node
                  delete head;
                  head = nullptr;
                  return;
                  }
                  Node* temp = head;
                  while (temp->next->next) {
                  temp = temp->next;
                  }
                  delete temp->next;
                  temp->next = nullptr;
                  }

                  // Delete in the middle (specific value)
                  void deleteValue(int value) {
                  if (!head) { // If the list is empty
                  cout << "List is empty!\n" ; return; } if (head->data == value) { // If the value is at the start
                    Node* temp = head;
                    head = head->next;
                    delete temp;
                    return;
                    }
                    Node* temp = head;
                    while (temp->next && temp->next->data != value) {
                    temp = temp->next;
                    }
                    if (temp->next) { // If the value is found
                    Node* toDelete = temp->next;
                    temp->next = temp->next->next;
                    delete toDelete;
                    } else {
                    cout << "Value not found!\n" ; } } // Search for a value bool search(int value) { Node* temp=head;
                      while (temp) { if (temp->data == value) {
                      return true;
                      }
                      temp = temp->next;
                      }
                      return false;
                      }

                      // Display the list
                      void display() {
                      Node* temp = head;
                      while (temp) {
                      cout << temp->data << " -> " ; temp=temp->next;
                          }
                          cout << "NULL\n" ; } // Destructor to free memory ~SinglyLinkedList() { Node* temp; while
                            (head) { temp=head; head=head->next;
                            delete temp;
                            }
                            }
                            };

                            int main() {
                            SinglyLinkedList list;

                            // Test insertion
                            list.insertAtStart(10);
                            list.insertAtStart(20);
                            list.insertAtEnd(30);
                            list.insertAfter(10, 25);

                            cout << "List after insertions: " ; list.display(); // Test deletion list.deleteAtStart();
                              cout << "List after deleting at start: " ; list.display(); list.deleteAtEnd(); cout
                              << "List after deleting at end: " ; list.display(); list.deleteValue(25); cout
                              << "List after deleting value 25: " ; list.display(); // Test search cout
                              << "Searching for 10: " << (list.search(10) ? "Found" : "Not Found" ) << "\n" ; cout
                              << "Searching for 40: " << (list.search(40) ? "Found" : "Not Found" ) << "\n" ; return 0;
                              } </code>
                              </pre>
              <button class="copy-button">Copy</button>
            </div>
          </div>
          <div id="pythonCode" class="code-block">
            <div class="code-content">
              <pre><code class="language-python">
# Python
 class Node:
    """A class representing a node in a singly linked list."""
    def __init__(self, data):
        self.data = data
        self.next = None


class SinglyLinkedList:
    """A class representing a singly linked list."""
    def __init__(self):
        self.head = None

    def insert_at_start(self, data):
        """Insert a new node at the start of the list."""
        new_node = Node(data)
        new_node.next = self.head
        self.head = new_node

    def insert_at_end(self, data):
        """Insert a new node at the end of the list."""
        new_node = Node(data)
        if not self.head:
            self.head = new_node
            return
        current = self.head
        while current.next:
            current = current.next
        current.next = new_node

    def insert_after(self, target, data):
        """Insert a new node after a specific node value."""
        current = self.head
        while current and current.data != target:
            current = current.next
        if current:
            new_node = Node(data)
            new_node.next = current.next
            current.next = new_node
        else:
            print("Target value not found!")

    def delete_at_start(self):
        """Delete the node at the start of the list."""
        if not self.head:
            print("List is empty!")
            return
        self.head = self.head.next

    def delete_at_end(self):
        """Delete the node at the end of the list."""
        if not self.head:
            print("List is empty!")
            return
        if not self.head.next:
            self.head = None
            return
        current = self.head
        while current.next and current.next.next:
            current = current.next
        current.next = None

    def delete_value(self, value):
        """Delete the first node with the given value."""
        if not self.head:
            print("List is empty!")
            return
        if self.head.data == value:
            self.head = self.head.next
            return
        current = self.head
        while current.next and current.next.data != value:
            current = current.next
        if current.next:
            current.next = current.next.next
        else:
            print("Value not found!")

    def search(self, value):
        """Search for a node with the given value."""
        current = self.head
        while current:
            if current.data == value:
                return True
            current = current.next
        return False

    def display(self):
        """Display the linked list."""
        current = self.head
        while current:
            print(current.data, end=" -> ")
            current = current.next
        print("NULL")


# Example usage
if __name__ == "__main__":
    linked_list = SinglyLinkedList()

    # Test insertion
    linked_list.insert_at_start(10)
    linked_list.insert_at_start(20)
    linked_list.insert_at_end(30)
    linked_list.insert_after(10, 25)

    print("List after insertions:")
    linked_list.display()

    # Test deletion
    linked_list.delete_at_start()
    print("List after deleting at start:")
    linked_list.display()

    linked_list.delete_at_end()
    print("List after deleting at end:")
    linked_list.display()

    linked_list.delete_value(25)
    print("List after deleting value 25:")
    linked_list.display()

    # Test search
    print("Searching for 10:", "Found" if linked_list.search(10) else "Not Found")
    print("Searching for 40:", "Found" if linked_list.search(40) else "Not Found")

                </code></pre>
              <button class="copy-button">Copy</button>
            </div>
          </div>
        </div>
      </div>

      <!-- Practice -->
      <div class="container" id="practice">
        <div class="title">Practice</div>
        <div class="content">
          <h4 id="instruction">In the Practice section of the simulation, you can visualize how a singly linked list
            works by performing insert, delete, and search operations. Start by entering comma-separated values (up to 8
            nodes max) and clicking "Create List" to generate the linked list. You can then choose an operation—Insert,
            Delete, or Search—and provide the necessary input (like value and index). Click "Run Simulation" to see the
            action animated step-by-step, showing how nodes are traversed, added, removed, or found.</h4>
          <br />
          <h1 id="head1">Singly Linked List Visualization</h1>

          <div class="controls">
            <input type="text" id="nodeValues" placeholder="Enter values (e.g., 10,20,30)">
            <button id="first_button" onclick="createList()">Create List</button>
            <button id="reset_button" onclick="reset()">Reset List</button>
          </div>

          <div id="operations" style="display: none;">
            <div class="controls_linked">
              <div id="button_god">
                <button onclick="showInsertFields()">Insert</button>
                <button id="deleteTabButton" onclick="showDeleteFields()">Delete</button>
                <button onclick="showSearchField()">Search</button>
              </div>
              <div class="input-container">

                <!-- Insert Fields -->
                <div class="inputlist" id="insertDeleteFields" style="display: none;">
                  <input type="number" id="nodeValue" placeholder="Enter the Element">
                  <input type="number" id="nodeIndex" placeholder="Enter the Index">
                </div>

                <!-- Delete Fields -->

                <div class="inputlist" id="deleteField" style="display: none;">
                  <input type="number" id="deleteValue" placeholder="Enter Value to Delete">
                  <input type="number" id="deleteindex" placeholder="Enter Delete Index">

                </div>

                <!-- Search Field -->
                <div class="inputlist" id="searchField" style="display: none;">
                  <input type="number" id="searchValue" placeholder="Search Value">
                </div>

                <!-- Run Simulation Button -->
                <button id="runSimulationButton" style="display: none;" onclick="runSimulation()">Run
                  Simulation</button>
              </div>
              <br />
              <p id="searchResult"></p>
              <h4><b>Note: <big>"∅"</big> represents to the Null Pointer in the linked list</b></h4>
            </div>
          </div>


          <div class="list-container" id="linkedList">
            <!-- Nodes will be dynamically added here -->
          </div>

        </div>
      </div>

      <!-- Results -->
      <div class="container" id="result">
        <div class="title">Result</div>
        <div class="content">
          <p>
            The Singly Linked List simulation successfully implemented insertion, deletion, and search operations. Nodes
            were correctly inserted at different positions, deleted as per specified conditions, and searched
            efficiently, returning the position if found or "not found" if not present. The operations performed as
            expected.
          </p>
        </div>
      </div>

      <!-- Quiz -->
      <div class="container" id="quiz">
        <h1 id="quiz_head">📝 Quiz</h1>
        <div id="quiz_main">
          <!-- <br/> -->
          <h3 id="question">Question</h3>
          <br />
          <div id="options">

          </div>

          <div id="last_btn">
            <button id="back" onclick=back_ques()>⬅️ Back</button>
            <button id="next" onclick=next_ques()>Next ➡️</button>
          </div>
        </div>

        <div id="result1">
          <h1>📜Summary</h1>
        </div>
        <button id="retake" onclick="retakeQuiz()">
          🔁 Retake Quiz
        </button>
      </div>

      <!-- References -->
      <div class="container" id="references">
        <div class="title">References</div>
        <div class="content">
          <ul class="ref-list">
            <li><span>Cormen, T. H., Leiserson, C. E., Rivest, R. L., & Stein, C. (2022). Introduction to algorithms.
                MIT press.</span></li>
            <li><span>Bhargava, A., & Bhargava, A. Y. (2024). Grokking algorithms. Simon and Schuster.</span></li>
            <li><span>A Complete Overview on: Web Development
                By- Ayush Mauryavanshi
              </span></li>
          </ul>
        </div>
      </div>

      <!-- Team & Tools -->
      <div class="container" id="tnt">
        <div class="title">Team & Tools</div>
        <div class="content">
          <h3>Students</h3>
          <ul class="ref-list">
            <li><a href="https://github.com/RISHIK396" rel="noopener" target="_blank"><span>Rishik Chaudhary
                  ,3<sup>rd</sup> year, BSc(Hons) Computer Science (2024-25)</span></a></li>
            <li><a href="https://github.com/KeshavKhari" rel="noopener" target="_blank"><span>Keshav Khari,
                  3<sup>rd</sup> year, BSc(Hons) Computer Science (2024-25)</span></a></li>
          </ul>
          <h3>Mentors</h3>
          <ul class="ref-list">
            <li><span>Mrs Priyanka Sharma</span></li>
            <li><span>Prof. Sharanjit Kaur</span></li>

          </ul>
          <h3>Tools Used</h3>
          <ul class="tools-list">
            <li><span>VS-Code</span></li>
            <li><span>HTML-5, CSS, JS - for creating the web page</span></li>
            <li><span>Figma,Canva - for designing figures and UI mockups</span></li>
            <li>
              <span>Vanilla HTML, CSS, JS - for creating the web page</span>
            </li>
          </ul>
        </div>
      </div>
    </section>
  </div>
  <script>
    hljs.highlightAll();
    function toggleMenu() {
      const menu = document.querySelector(".nav-menu");
      menu.classList.toggle("show");
    }
  </script>
  <script src="script.js"></script>
</body>

</html>





<!-- 

-->




<!-- 
        <h3>Insertion-></h3>
        <br />
        content wala part down

<p>The Procedure for Insertion in a Linked List</p>
          <br/>
          <ol class="steps-list" start="1">
            <li><b>Insertion At the begining:</b></li>
            </ol>
            <ul type="i">
              <li>Create a new node.</li>
              <li>Point the new node’s next to the current head.</li>
              <li>Update the head to the new node.</li>
            </ul>
            <ol class="steps-list" start="2"><li> <b> Insertion At the End:</b></li></ol>
            <ul>
              <li>Create a new node</li>
              <li>Traverse the list to find the new node</li>
              <li>Point the last node next to new node</li>
            </ul>

            <ol class="steps-list" start="3"><li> <b>Insertion in the middle of the linked list:</b></li></ol>
            <ul>
              <li>Create a new node</li>
              <li>Traverse the list to the node just before the specified position.</li>
              <li>Update the pointers to insert the new node in the desired position.</li>
            </ul>
          </li>
        </div>
        <br/>
        <h3>Deletion-></h3>
        <br/>
        <div class="content">
          <p>The procedure for Delting a Linked list</p>
          <br/>
          <ol>
            <li><b>Deletion from the Start:</b></li></ol>
            <ul>
              <li> If head is None, return (list is empty).</li>
              <li>Set head = head.next.</li>
            </ul>

            <ol start="2">
            <li><b>Deletion from the End:</b></li></ol>
            <ul>
              <li>If head is None, return (list is empty).</li>
              <li>Traverse to the second last node.</li>
              <li>Set second_last.next = None. </li>
            </ul>
            
            <ol start="3">
            <li><b>Deletion from the middle:</b></li></ol>
            <ul>
              <li>If position is 1, update head = head.next.</li>
              <li>Otherwise, traverse to the node before the desired position.</li>
              <li>Set current_node.next = current_node.next.next.</li>
            </ul>
-->