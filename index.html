<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="description" content="brief description" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SINGLY LINKED LIST</title>
  <link rel="icon" href="images/vlab-logo.png" type="image/x-icon" />
  <link rel="stylesheet" href="styles.css" />
  <link rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/base16/harmonic16-dark.min.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.8/clipboard.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
</head>

<body>
  <header class="header">
    <div class="logo-container">
      <div class="logo">
        <a href="https://www.vlab.andcollege.du.ac.in" rel="noopener" target="_blank">
          <img class="logo-img" src="images/logo.png" alt="VLab" />
        </a>
      </div>
      <h1 class="vlab">V-Lab@ANDC</h1>
    </div>

    <div class="menu-toggle" onclick="toggleMenu()">‚ò∞</div>
    <nav class="nav-menu" id="small-screen">
      <div class="close-btn" onclick="toggleMenu()">‚úñ</div>
      <a href="https://www.vlab.andcollege.du.ac.in">Home</a>
      <a href="https://www.vlab.andcollege.du.ac.in#labs_section">Labs</a>
      <a href="https://www.vlab.andcollege.du.ac.in#team">Team</a>
      <a href="https://www.andcollege.du.ac.in">College Website</a>
    </nav>
  </header>

  <div class="yourvlabtitle">
    <h1><b>SINGLY LINKED LIST</b></h1>
  </div>

  <div class="pageview">
    <nav class="navigation">
      <button class="link" onclick="switchContent('aim')">
        <img class="icon" src="images/Aim_img.png" alt="Aim" />
        <span>Aim</span>
      </button>

      <button class="link" onclick="switchContent('theory')">
        <img class="icon" src="images/theory_img.png" alt="THEORY & Application" />
        <span>Theory & Application</span>
      </button>

      <button class="link" onclick="switchContent('procedure')">
        <img class="icon" src="images/procedure_img.png" alt="PROCEDURE" />
        <span>Procedure</span>
      </button>

      <button class="link" onclick="switchContent('practice')">
        <img class="icon" src="images/practice_img.png" alt="PRACTICE" />
        <span>Practice</span>
      </button>

      <button class="link" onclick="switchContent('code')">
        <img class="icon" src="images/code_img.png" alt="CODES" />
        <span>Codes</span>
      </button>

      <button class="link" onclick="switchContent('result')">
        <img class="icon" src="images/result_img.png" alt="RESULT" />
        <span>Result</span>
      </button>

      <button class="link" onclick="switchContent('quiz')">
        <img class="icon" src="images/quiz_img.png" alt="QUIZ" />
        <span>Quiz</span>
      </button>

      <button class="link" onclick="switchContent('references')">
        <img class="icon" src="images/reference_img.png" alt="REFERENCE" />
        <span>References</span>
      </button>
      <button class="link" onclick="switchContent('tnt')">
        <img class="icon" src="images/tnt_img.png" alt="TEAM & TOOLS" />
        <span>Team & Tools</span>
      </button>
    </nav>

    <section class="main_practical">
      <!-- Aim -->
      <div class="container" id="aim">
        <div class="title">Aim</div>
        <div class="content">
          <p> To demonstrate the working of a Singly Linked List (SLL), which includes its creation, traversal ,
            insertion of elements, deletion of elements, and search for elements through visualization.</p>
        </div>
      </div>

      <!-- Theory & Applications -->
      <div class="container" id="theory">
        <div class="title">Theory & Applications </div>
        <div class="content">
          <p>
            A <b>Singly Linked List</b> (SLL) is a linear data structure consisting of nodes in which each node is
            accessible through pointer stored in its immediate predecessor. Single linked list is traversed from first
            node to the last node using pointers in the forward direction only. It is not feasible to randomly access
            any element in the list. The first node is pointed by head node which contains the address of first node.
            Initially, head is Null (‚àÖ) indicating empty linked list.
          </p>
          <br />

          <h3>In a Singly Linked List, each node contains two components:</h3>
          <br>
          <span>
            <ul>
              <li>
                <p><b>Data :</b></p>
              </li>
              <p>This stores the actual value or information (e.g., an integer, string, object, etc.).</p>
              <span>Example: 5, "Hello", {name: "Alice", age: 30}, etc.</span>
            </ul>
            <ul>
              <li>  
                <p><b>Pointer (or Next):</b></p>
              </li>
              <span><p>This holds the reference or address of the next node in the list. If it's the last node, the
                  pointer is set to null (or None in Python).</p></span>
            </ul>
          </span>
          <br />
          <div class="content_all">
            <h1>Applications of Singly Linked List: </h1>
            <br />
            <ol start="1">
              <li><b> Memory Allocation by the Operating System : </b></li>
            </ol>
            <ul>
              <li><b> Use-case : </b></li>
              <p>Operating Systems and memory managers.</p>
              <br />
              <li><b>Explanation : </b></li>
              <p>Singly linked lists are used to keep track of free and allocated memory blocks in heap management. Each
                memory block contains a pointer to the next block</p>
              <br />
              <li><b>Application : </b></li>
              <p>Efficient insertion and deletion of memory blocks.</p>
            </ul>
            <ol start="2">
              <li><b>Undo Functionality in Applications</b></li>
            </ol>
            <ul>
              <li><b> Use-case : </b></li>
              <p> Text editors like Microsoft Word, Google Docs.</p>
              <br />
              <li><b>Explanation : </b></li>
              <p>Each action (e.g., typing a letter) is stored as a node. Pressing "undo"
                traverses back through the actions using the links.</p>
              <br />
              <li><b>Application : </b></li>
              <p> Enables efficient rollback of previous operations.</p>
            </ul>
            <ol start="3">
              <li><b>Web Browser Forward Navigation</b></li>
            </ol>
            <ul>
              <li><b> Use-case : </b></li>
              <p> Web browsers.</p>
              <br />
              <li><b>Explanation : </b></li>
              <p>While back navigation uses a stack, forward navigation (redoing pages) can
                be managed using a singly linked list.</p>
              <br />
              <li><b>Application : </b></li>
              <p> Allows efficient forward traversal through visited pages.</p>
            </ul>
            <ol start="4">
              <li><b> Polynomial Arithmetic</b></li>
            </ol>
            <ul>
              <li><b> Use-case : </b></li>
              <p> Scientific and Engineering computations.</p>
              <br />
              <li><b>Explanation : </b></li>
              <p> Polynomials can be represented as a linked list where each node holds a
                coefficient and exponent.</p>
              <br />
              <li><b>Application : </b></li>
              <p> Enables efficient polynomial addition, subtraction, and multiplication without
                memory waste.</p>
            </ul>
            <ol start="5">
              <li><b>Real-time Task Scheduling</b></li>
            </ol>
            <ul>
              <li><b> Use-case : </b></li>
              <p> Embedded systems and OS kernels.</p>
              <br />
              <li><b>Explanation : </b></li>
              <p> A task queue can be implemented as a singly linked list where each task is a
                node.</p>
              <br />
              <li><b>Application : </b></li>
              <p> Easy insertion of new tasks and deletion of completed ones in linear time.
              </p>
            </ul>
          </div>
        </div>

      </div>

      <!-- Linked List Procedure Section -->
<div class="container" id="procedure">
  <div class="title"><b>Key Operations On SLL</b></div>
  <div class="content">
    <p>
      This section illustrates key operations on a singly linked list, including <b>insertions</b> and <b>deletions</b> at
        indices <b>0, 3, and 4</b>. The operations are demonstrated using an initial linked list with four nodes:
        <b>Node A, Node B, Node C, and Node D.</b>
    </p>
    <br><br>

    <img id="s1_img" src="s1.png" alt="Initial Linked List">
    <br /><br />

    <!-- Insertion Section -->
    <h2>Insertion</h2>
    <br>
    <p>
      Insertion in a singly linked list involves creating a new node and adjusting pointers to place it at the
      desired position without disrupting the structure of the list.
    </p>
    <br>

    <!-- Insertion at Index 1 -->
    <h3>Insertion Before the First Node:</h3>
    <br>
    <ol>
      <li>Create a new node (Node D).</li>
      <li>Set Node D‚Äôs next pointer to the current head (Node A).</li>
      <li>Update the head to point to Node D.</li>
    </ol>
    <br>

    <img id="s2_img" src="s2.png" alt="Insertion at Index 1">
    <h4>Result:</h4>
    <img id="s3_img" src="s3.png" alt="Result after insertion at index 1">
    <br> <br>
    <h4>Time Complexity:</h4>
    <p><b>O(1)</b> ‚Äì Direct pointer reassignment makes this a constant-time operation.</p>

    <br /><br /><br />

    <!-- Insertion at Index 3 -->
    <h3>Insertion at third position</h3>
    <br>
    <ol>
      <li>Create a new node (Node D).</li>
      <li>Traverse the list to the node before the desired position (Node B).</li>
      <li>Set Node D‚Äôs next pointer to the next node (Node C).</li>
      <li>Update Node B‚Äôs next pointer to point to Node D.</li>
    </ol>
    <br>

    <img id="s4_img" src="s4.png" alt="Insertion at Index 3">
    <h4>Result:</h4>
    <img id="s5_img" src="s5.png" alt="Result after insertion at index 3">
    <br><br>
    <h4>Time Complexity:</h4>
    <p><b>O(n)</b> ‚Äì Requires traversal to the desired position.</p>

    <br /><br /><br />

    <!-- Insertion at Index 4 -->
    <h3>Insertion at the end of the list</h3>
    <br>
    <ol>
      <li>Create a new node (Node D).</li>
      <li>Traverse the list to the last node (Node C).</li>
      <li>Set Node C‚Äôs next pointer to Node D.</li>
    </ol>
    <br>

    <img id="s6_img" src="s6.png" alt="Insertion at Index 4">
    <h4>Result:</h4>
    <img id="s7_img" src="s7.png" alt="Result after insertion at index 4">
    <br><br>
    <h4>Time Complexity:</h4>
    <p><b>O(n)</b> ‚Äì Entire list traversal is needed to reach the last node.</p>

    <br /><br /><br />

    <!-- Deletion Section -->
     <h2>Deletion</h2>
    <br>
    <p>
      Deletion in a singly linked list involves removing a node 
      from the desired position by adjusting the pointers of the preceding node, ensuring the continuity of the list structure.
    </p>
    <br>

    <!-- Deletion at Index 1 -->
    <h3>Deletion at position one</h3>
    <br>
    <ol>
      <li>Identify the head node (Node A).</li>
      <li>Update the head to point to the second node (Node B).</li>
    </ol>
    <br>


    <img id="s8_img" src="s8.png" alt="Deletion at Index 1">
    <h4>Result:</h4>
    <img id="s9_img" src="s9.png" alt="Result after deletion at index 1">
    <br><br>
    <h4>Time Complexity:</h4>
    <p><b>O(1)</b> ‚Äì Only the head pointer is changed.</p>

    <br /><br /><br />

    <!-- Deletion at Index 3 -->
    <h3>Deletion at third position</h3>
    <br>
    <ol>
      <li>Traverse the list to the node before the one to delete (Node B).</li>
      <li>Update Node B‚Äôs next pointer to skip Node C and point to Node D.</li>
    </ol>
    <br>

    <img id="s10_img" src="s10.png" alt="Deletion at Index 3">
    <h4>Result:</h4>
    <img id="s11_img" src="s11.png" alt="Result after deletion at index 3">
    <br><br>
    <h4>Time Complexity:</h4>
    <p><b>O(n)</b> ‚Äì Traversal is needed to reach the node before the one to be deleted.</p>

    <br /><br /><br />

    <!-- Deletion at Index 4 -->
    <h3>Deletion at the end of the list</h3>
    <br>
    <ol>
      <li>Traverse the list to find the second-to-last node (Node C).</li>
      <li>Set Node C‚Äôs next pointer to <code>NULL</code>, disconnecting Node D.</li>
    </ol>
    <br>

    <img id="s12_img" src="s12.png" alt="Deletion at Index 4">
    <h4>Result:</h4>
    <img id="s13_img" src="s13.png" alt="Result after deletion at index 4">
    <br><br>
    <h4>Time Complexity:</h4>
    <p><b>O(n)</b> ‚Äì Requires traversal to the end of the list.</p>

    <br /><br />
  </div>
</div>


      <!-- Code -->
      <div class="container" id="code">
        <div class="title">Code</div>
        <p>Example programs</p>
        <div class="switch-container">
          <input class="togswt" type="radio" id="cppRadio" name="codeSwitch" checked />
          <label for="cppRadio">C++</label>

          <input class="togswt" type="radio" id="pythonRadio" name="codeSwitch" />
          <label for="pythonRadio">Python</label>
        </div>

        <div class="code-blocks">
          <div id="cppCode" class="code-block active">
            <div class="code-content">
              <pre><code class="language-cpp">
        #C++ code        

        <!-- &lt and &gt for including the angular brackets in html code -->
              #include &lt;iostream&gt;
              using namespace std;

              // Node class
              class Node {
              private:
              int data;
              Node* next;

              public:
              Node(int value) { // Constructor to initialize a node
              data = value;
              next = nullptr;
              }

              friend class SinglyLinkedList;
              };

              // Singly Linked List class
              class SinglyLinkedList {
              private:
              Node* head; // Pointer to the first node

              public:
              // Constructor
              SinglyLinkedList() {
              head = nullptr;
              }

              // Insert at the start
              void insertAtStart(int value) {
              Node* newNode = new Node(value);
              newNode->next = head;
              head = newNode;
              }

              // Insert at the end
              void insertAtEnd(int value) {
              Node* newNode = new Node(value);
              if (!head) { // If the list is empty
              head = newNode;
              return;
              }
              Node* temp = head;
              while (temp->next) {
              temp = temp->next;
              }
              temp->next = newNode;
              }

              // Insert in the middle (after a given value)
              void insertAfter(int target, int value) {
              Node* temp = head;
              while (temp && temp->data != target) {
              temp = temp->next;
              }
              if (temp) { // If the target node is found
              Node* newNode = new Node(value);
              newNode->next = temp->next;
              temp->next = newNode;
              } else {
              cout << "Target value not found!\n" ; } } // Delete at the start void deleteAtStart() { if (!head) { // If
                the list is empty cout << "List is empty!\n" ; return; } Node* temp=head; head=head->next;
                delete temp;
                }

                // Delete at the end
                void deleteAtEnd() {
                if (!head) { // If the list is empty
                cout << "List is empty!\n" ; return; } if (!head->next) { // If there is only one node
                  delete head;
                  head = nullptr;
                  return;
                  }
                  Node* temp = head;
                  while (temp->next->next) {
                  temp = temp->next;
                  }
                  delete temp->next;
                  temp->next = nullptr;
                  }

                  // Delete in the middle (specific value)
                  void deleteValue(int value) {
                  if (!head) { // If the list is empty
                  cout << "List is empty!\n" ; return; } if (head->data == value) { // If the value is at the start
                    Node* temp = head;
                    head = head->next;
                    delete temp;
                    return;
                    }
                    Node* temp = head;
                    while (temp->next && temp->next->data != value) {
                    temp = temp->next;
                    }
                    if (temp->next) { // If the value is found
                    Node* toDelete = temp->next;
                    temp->next = temp->next->next;
                    delete toDelete;
                    } else {
                    cout << "Value not found!\n" ; } } // Search for a value bool search(int value) { Node* temp=head;
                      while (temp) { if (temp->data == value) {
                      return true;
                      }
                      temp = temp->next;
                      }
                      return false;
                      }

                      // Display the list
                      void display() {
                      Node* temp = head;
                      while (temp) {
                      cout << temp->data << " -> " ; temp=temp->next;
                          }
                          cout << "NULL\n" ; } // Destructor to free memory ~SinglyLinkedList() { Node* temp; while
                            (head) { temp=head; head=head->next;
                            delete temp;
                            }
                            }
                            };

                            int main() {
                            SinglyLinkedList list;

                            // Test insertion
                            list.insertAtStart(10);
                            list.insertAtStart(20);
                            list.insertAtEnd(30);
                            list.insertAfter(10, 25);

                            cout << "List after insertions: " ; list.display(); // Test deletion list.deleteAtStart();
                              cout << "List after deleting at start: " ; list.display(); list.deleteAtEnd(); cout
                              << "List after deleting at end: " ; list.display(); list.deleteValue(25); cout
                              << "List after deleting value 25: " ; list.display(); // Test search cout
                              << "Searching for 10: " << (list.search(10) ? "Found" : "Not Found" ) << "\n" ; cout
                              << "Searching for 40: " << (list.search(40) ? "Found" : "Not Found" ) << "\n" ; return 0;
                              } </code>
                              </pre>
              <button class="copy-button">Copy</button>
            </div>
          </div>
          <div id="pythonCode" class="code-block">
            <div class="code-content">
              <pre><code class="language-python">
# Python
 class Node:
    """A class representing a node in a singly linked list."""
    def __init__(self, data):
        self.data = data
        self.next = None


class SinglyLinkedList:
    """A class representing a singly linked list."""
    def __init__(self):
        self.head = None

    def insert_at_start(self, data):
        """Insert a new node at the start of the list."""
        new_node = Node(data)
        new_node.next = self.head
        self.head = new_node

    def insert_at_end(self, data):
        """Insert a new node at the end of the list."""
        new_node = Node(data)
        if not self.head:
            self.head = new_node
            return
        current = self.head
        while current.next:
            current = current.next
        current.next = new_node

    def insert_after(self, target, data):
        """Insert a new node after a specific node value."""
        current = self.head
        while current and current.data != target:
            current = current.next
        if current:
            new_node = Node(data)
            new_node.next = current.next
            current.next = new_node
        else:
            print("Target value not found!")

    def delete_at_start(self):
        """Delete the node at the start of the list."""
        if not self.head:
            print("List is empty!")
            return
        self.head = self.head.next

    def delete_at_end(self):
        """Delete the node at the end of the list."""
        if not self.head:
            print("List is empty!")
            return
        if not self.head.next:
            self.head = None
            return
        current = self.head
        while current.next and current.next.next:
            current = current.next
        current.next = None

    def delete_value(self, value):
        """Delete the first node with the given value."""
        if not self.head:
            print("List is empty!")
            return
        if self.head.data == value:
            self.head = self.head.next
            return
        current = self.head
        while current.next and current.next.data != value:
            current = current.next
        if current.next:
            current.next = current.next.next
        else:
            print("Value not found!")

    def search(self, value):
        """Search for a node with the given value."""
        current = self.head
        while current:
            if current.data == value:
                return True
            current = current.next
        return False

    def display(self):
        """Display the linked list."""
        current = self.head
        while current:
            print(current.data, end=" -> ")
            current = current.next
        print("NULL")


# Example usage
if __name__ == "__main__":
    linked_list = SinglyLinkedList()

    # Test insertion
    linked_list.insert_at_start(10)
    linked_list.insert_at_start(20)
    linked_list.insert_at_end(30)
    linked_list.insert_after(10, 25)

    print("List after insertions:")
    linked_list.display()

    # Test deletion
    linked_list.delete_at_start()
    print("List after deleting at start:")
    linked_list.display()

    linked_list.delete_at_end()
    print("List after deleting at end:")
    linked_list.display()

    linked_list.delete_value(25)
    print("List after deleting value 25:")
    linked_list.display()

    # Test search
    print("Searching for 10:", "Found" if linked_list.search(10) else "Not Found")
    print("Searching for 40:", "Found" if linked_list.search(40) else "Not Found")

                </code></pre>
              <button class="copy-button">Copy</button>
            </div>
          </div>
        </div>
      </div>

      <!-- Practice -->
      <div class="container" id="practice">
        <div class="title">Practice</div>
        <div class="content">
          <h4>This section demonstrates the basic operations like insert, delete, and search operations thru visual-rich simulation . Follow the given steps for practicing:</h4>
          <ol id="practise_step">
            <li>Enter comma-separated values (up to maximum  8 values) and click on "Create List" to generate the linked list.</li>
            <li>Choose an operation‚ÄîInsert, Delete, or Search‚Äîand provide the necessary input (like value and position).</li>
            <li>Click "Run Simulation" to see the animated visuals, preforming the desired operation step- by-step</li>
          </ol>
          <br />
          <br>
          <h1 id="head1">Singly Linked List Visualization</h1>

          <div class="controls">
            <input type="text" id="nodeValues" placeholder="Enter values (e.g., 10,20,30)">
           <div id="two_butt">
             <button id="first_button" onclick="createList()">Create List</button>
            <button id="reset_button" onclick="reset()">Reset List</button>
           </div>
          </div>

          <div id="operations" style="display: none;">
            <div class="controls_linked">
              <div id="button_god">
                <button onclick="showInsertFields()">Insert</button>
                <button id="deleteTabButton" onclick="showDeleteFields()">Delete</button>
                <button onclick="showSearchField()">Search</button>
              </div>
              <div class="input-container">

                <!-- Insert Fields -->
                <div class="inputlist" id="insertDeleteFields" style="display: none;">
                  <input type="number" id="nodeValue" placeholder="Enter the Element">
                  <input type="number" id="nodeIndex" placeholder="Enter the Index">
                </div>

                <!-- Delete Fields -->

                <div class="inputlist" id="deleteField" style="display: none;">
                  <input type="number" id="deleteValue" placeholder="Enter Value to Delete">
                  <input type="number" id="deleteindex" placeholder="Enter Delete Index">

                </div>

                <!-- Search Field -->
                <div class="inputlist" id="searchField" style="display: none;">
                  <input type="number" id="searchValue" placeholder="Search Value">
                </div>

                <!-- Run Simulation Button -->
                <button id="runSimulationButton" style="display: none;" onclick="runSimulation()">Run
                  Simulation</button>
              </div>
              <br />
              <p id="searchResult"></p>
            </div>
          </div>


          <div class="list-container" id="linkedList">
            <!-- Nodes will be dynamically added here -->
          </div>

        </div>
      </div>

      <!-- Results -->
      <div class="container" id="result">
        <div class="title">Result</div>
        <div class="content">
          <p>
           The designed virtual lab (VLab) demonstrated the implementation of a singly linked list with a maximum of eight elements in an interactive way. It successfully allowed users to perform key operations such as insertion, deletion, and search, visually showcasing the step-by-step pointer adjustments involved in each operation and reinforcing the underlying logic of linked list manipulation.
          </p>
        </div>
      </div>

      <!-- Quiz -->
      <div class="container" id="quiz">
        <h1 id="quiz_head">Quiz</h1>
        <div id="quiz_main">
          <!-- <br/> -->
          <h3 id="question">Question</h3>
          <br />
          <div id="options">

          </div>

          <div id="last_btn">
            <button id="back" onclick=back_ques()>Back</button>
            <button id="next" onclick=next_ques()>Next</button>
          </div>
        </div>

        <div id="result1">
          <h1>üìúSummary</h1>
        </div>
        <button id="retake" onclick="retakeQuiz()">
          üîÅ Retake Quiz
        </button>
      </div>

      <!-- References -->
      <div class="container" id="references">
        <div class="title">References</div>
        <div class="content">
          <ul class="ref-list">
            <li><a href="https://books.google.co.in/books?hl=en&lr=&id=RSMuEAAAQBAJ&oi=fnd&pg=PR13&dq=Cormen,+T.+H.,+Leiserson,+C.+E.,+Rivest,+R.+L.,+%26+Stein,+C.+(2022).+Introduction+to+algorithms.+++++++++++++++++MIT+press.&ots=a3l3WZ2HRH&sig=wAPl3qslVLuMUHPOfHSzVvb90BM&redir_esc=y#v=onepage&q&f=false">Cormen, T. H., Leiserson, C. E., Rivest, R. L., & Stein, C. (2022). Introduction to algorithms.
                MIT press.</a></li>
            <li><a href="https://books.google.co.in/books?hl=en&lr=&id=rcj3EAAAQBAJ&oi=fnd&pg=PR13&dq=Bhargava,+A.,+%26+Bhargava,+A.+Y.+(2024).+Grokking+algorithms.+Simon+and+Schuster.&ots=hGRhw_PRFm&sig=j-gZOsLWXwZ4OdFDMPDcEtGZ35E&redir_esc=y#v=onepage&q&f=false">Bhargava, A., & Bhargava, A. Y. (2024). Grokking algorithms. Simon and Schuster.</a></li>
          </ul>
        </div>
      </div>

      <!-- Team & Tools -->
      <div class="container" id="tnt">
        <div class="title">Team & Tools</div>
        <div class="content">
          <h3>Students</h3>
          <ul class="ref-list">
            <li><a href="https://github.com/RISHIK396" rel="noopener" target="_blank"><span>Rishik Chaudhary
                  ,3<sup>rd</sup> year, BSc(Hons) Computer Science (2024-25)</span></a></li>
            <li><a href="https://github.com/KeshavKhari" rel="noopener" target="_blank"><span>Keshav Khari,
                  3<sup>rd</sup> year, BSc(Hons) Computer Science (2024-25)</span></a></li>
          </ul>
          <h3>Mentors</h3>
          <ul class="ref-list">
            <li><span>Ms. Priyanka Sharma</span></li>
            <li><span>Prof. Sharanjit Kaur</span></li>

          </ul>
          <h3>Tools Used</h3>
          <ul class="tools-list">
            <li><span>HTML(v5.2), CSS Snapshot 2023, JavaScript (ES‚ÄØ6)</span></li>
            <li><span>Figma(v124.4.7), Canva</span></li>
          </ul>
        </div>
      </div>
    </section>
  </div>
  <script>
    hljs.highlightAll();
    function toggleMenu() {
      const menu = document.querySelector(".nav-menu");
      menu.classList.toggle("show");
    }
  </script>
  <script src="script.js"></script>
</body>

</html>
